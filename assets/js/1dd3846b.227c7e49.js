"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[6084],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return m}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(t),m=r,y=u["".concat(l,".").concat(m)]||u[m]||d[m]||o;return t?a.createElement(y,i(i({ref:n},p),{},{components:t})):a.createElement(y,i({ref:n},p))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},4254:function(e,n,t){t.r(n),t.d(n,{assets:function(){return p},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return d}});var a=t(7462),r=t(3366),o=(t(7294),t(3905)),i=["components"],s={},l="IOC support via DI",c={unversionedId:"general/dependencyInjection",id:"general/dependencyInjection",title:"IOC support via DI",description:"Discordx supports multiple DI containers to help you efficiently manage and architect large applications that wish to take advantage of an IOC paradigm",source:"@site/docs/general/dependencyInjection.md",sourceDirName:"general",slug:"/general/dependencyInjection",permalink:"/docs/general/dependencyInjection",editUrl:"https://github.com/oceanroleplay/discord.ts/edit/main/docs/docs/general/dependencyInjection.md",tags:[],version:"current",lastUpdatedBy:"oceanroleplay",lastUpdatedAt:1650365528,formattedLastUpdatedAt:"4/19/2022",frontMatter:{},sidebar:"docSidebar",previous:{title:"Sharding",permalink:"/docs/general/sharding"},next:{title:"@Slash - Discord commands",permalink:"/docs/decorators/commands/slash"}},p={},d=[{value:"Configuration",id:"configuration",level:2},{value:"Usage",id:"usage",level:2},{value:"Note for TSyringe",id:"note-for-tsyringe",level:3},{value:"Getting all @Discord classes",id:"getting-all-discord-classes",level:2}],u={toc:d};function m(e){var n=e.components,t=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"ioc-support-via-di"},"IOC support via DI"),(0,o.kt)("p",null,"Discordx supports multiple DI containers to help you efficiently manage and architect large applications that wish to take advantage of an IOC paradigm"),(0,o.kt)("p",null,"Another use for this approach is that sometimes, you will find yourself wanting to get hold of objects and instances and might have been tempted to just put them on the Client, or extend the Client object with your own custom Client class and just put everything there. This is fine in a pure JS way, but causes issues especially with maintenance and managing, as well as having to unsafely cast your Client."),(0,o.kt)("p",null,"So, if you have a large codebase and are using one of our supported DI containers to inject dependency, Discordx can now utilize the container to register each annotated ",(0,o.kt)("inlineCode",{parentName:"p"},"@Discord()")," class!"),(0,o.kt)("p",null,"In order to use your container, there is some small configuration to do in your code"),(0,o.kt)("h2",{id:"configuration"},"Configuration"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Supported DI containers:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"TSyringe"),(0,o.kt)("li",{parentName:"ul"},"TypeDi")),(0,o.kt)("p",null,"Before you import or define any ",(0,o.kt)("inlineCode",{parentName:"p"},"@Discord")," classes, you must bind your di container to discordx (Whether imported from ",(0,o.kt)("inlineCode",{parentName:"p"},"importx")," or another custom loader). To accomplish this, simply add ",(0,o.kt)("inlineCode",{parentName:"p"},"DIService.container = container")," before the aforementioned importer, As shown in the examples below."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="TSyringe"',title:'"TSyringe"'},'import { container } from "tsyringe";\nimport { DIService } from "discordx";\n\nDIService.container = container;\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="TypeDi"',title:'"TypeDi"'},'import { DIService } from "discordx";\nimport { Container } from "typedi";\n\nDIService.container = Container;\n')),(0,o.kt)("p",null,"It is recommended to do this in your main class where you define your ",(0,o.kt)("inlineCode",{parentName:"p"},"new Client()")," code; for example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import "reflect-metadata";\nimport { Intents } from "discord.js";\nimport { container } from "tsyringe";\nimport { Client, DIService } from "discordx";\n\nasync function start() {\n  DIService.container = container;\n  const client = new Client({\n    botId: "test",\n    intents: [Intents.FLAGS.GUILDS, Intents.FLAGS.GUILD_MESSAGES],\n    silent: false,\n  });\n\n  await client.login("YOUR_TOKEN");\n}\n\nstart();\n')),(0,o.kt)("h2",{id:"usage"},"Usage"),(0,o.kt)("p",null,"Once you have told Discordx to use your container for DI, it will then register all of your defined ",(0,o.kt)("inlineCode",{parentName:"p"},"@Discord()")," classes with the container as singletons. This is the same as declaring a class in TSyringe as ",(0,o.kt)("inlineCode",{parentName:"p"},"@singleton()")," or with TypeDI ",(0,o.kt)("inlineCode",{parentName:"p"},"@Service"),"."),(0,o.kt)("h3",{id:"note-for-tsyringe"},"Note for TSyringe"),(0,o.kt)("p",null,"In TSyringe classes declared with ",(0,o.kt)("inlineCode",{parentName:"p"},"@singleton()")," are automatically ",(0,o.kt)("inlineCode",{parentName:"p"},"@injectable()")," but in Discordx you must add this annotation too if you wish your classes to receive constructor injection."),(0,o.kt)("p",null,"For example, say you have a Database class you wish to inject into your declared ",(0,o.kt)("inlineCode",{parentName:"p"},"@Discord()")," class:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'@singleton()\nclass Database {\n  database: string;\n\n  constructor() {\n    console.log("I am database");\n    this.database = "connected";\n  }\n\n  query() {\n    return this.database;\n  }\n}\n')),(0,o.kt)("p",null,"In order to get this class injected into your ",(0,o.kt)("inlineCode",{parentName:"p"},"@Discord()")," instance at runtime, you must define your class as both ",(0,o.kt)("inlineCode",{parentName:"p"},"@Discord()")," ",(0,o.kt)("strong",{parentName:"p"},"AND")," ",(0,o.kt)("inlineCode",{parentName:"p"},"@injectable()"),": (the order is important)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'@Discord()\n@injectable()\nclass Example {\n  constructor(private _database: Database) {\n    console.log("constructed me as a singleton and injected _database");\n  }\n\n  @Slash("tsyringe")\n  private tsyringe(interaction: CommandInteraction): void {\n    if (DIService.container) {\n      // resolve class\n      const clazz = container.resolve(Example);\n\n      // respond with class test\n      interaction.reply(\n        `${clazz._database.query()}, same class: ${clazz === this}`\n      );\n    } else {\n      // warn: TSyringe is not used\n      interaction.reply("Not using TSyringe");\n    }\n  }\n}\n')),(0,o.kt)("p",null,"When running the above code, your ",(0,o.kt)("inlineCode",{parentName:"p"},"database")," will be injected into your ",(0,o.kt)("inlineCode",{parentName:"p"},"Example")," class and when you ask your container for ",(0,o.kt)("inlineCode",{parentName:"p"},"Example")," you always receive the same instance of the class ",(0,o.kt)("inlineCode",{parentName:"p"},"container.resolve(Example);")),(0,o.kt)("p",null,"If you do not mark the class as ",(0,o.kt)("inlineCode",{parentName:"p"},"@injectable()")," you will get an error thrown from TSyringe telling you where is no type info for your class."),(0,o.kt)("p",null,"For TypeDI, you do not need to mark your classes, all DI works as expected, along with ",(0,o.kt)("inlineCode",{parentName:"p"},"@Inject")," for props and constructor overrides with other services."),(0,o.kt)("h2",{id:"getting-all-discord-classes"},"Getting all @Discord classes"),(0,o.kt)("p",null,"If for some reason, you wish to get all instances of the ",(0,o.kt)("inlineCode",{parentName:"p"},"@Discord")," classes in your bot, then you can do so with the following code example:"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"NOTE"),": this will constructor all your classes in the DI container, if you wish to lazy-load your singletons, then you can not do this."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { container } from "tsyringe";\nimport { DIService } from "discordx";\nimport { Container } from "typedi";\n\nfunction getAllDiscordClasses(): unknown[] {\n  const appClasses = DIService.allServices;\n\n  // store resolved classes from TSyringe resolve\n  const commandClasses = [];\n\n  // resolve all classes\n  for (const classRef of appClasses) {\n    // TSyringe\n    const instance = container.resolve(classRef as constructor<unknown>);\n\n    // TypeDI\n    const instance = Container.get(classRef as constructor<unknown>);\n\n    commandClasses.push(instance);\n  }\n\n  return commandClasses;\n}\n')),(0,o.kt)("p",null,"Because your container has been populated with all the ",(0,o.kt)("inlineCode",{parentName:"p"},"@Discord()")," instances on startup, you can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"MetadataStorage")," object to get all the class refs for all the components and use a unique set of said classes to resolve them from your container"),(0,o.kt)("p",null,"Unfortunately, we can not use ",(0,o.kt)("inlineCode",{parentName:"p"},"@injectall()")," with tokenized dependencies, because ",(0,o.kt)("inlineCode",{parentName:"p"},"@Discord()")," is proxying your container, it cannot create a registry dynamically."))}m.isMDXComponent=!0}}]);